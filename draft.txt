class Expression {
    virtual int eval (Context& c) = 0;
    virtual int varCount() ;
}

class Variable : Expression {
    std::string name;

    ...

    int eval (Context& c) {
        return c.search(name);
    }

    int varCount () {
        return 1;
    }

}

class Literal : Expression {
    int _value;

    Literal (int value) : _value (value) {
        
    }

    int eval (Context& c) {
        return c.search(name);
    }

    int varCount () {
        return 0;
    }

}

class SumOperation : Expression {
    Expression *_e1, *_e2;

    SumOperation(e1, e2) : ... {}

    int eval (Context) {    
        return _e1->eval(c) + _e2->eval(c);
    }
}

DÃºvida: Constraint vs Expression. Queremos distinguir? Como? Ter Type, mas int na mesma.


class Expression {
    Type* type;
    
    Value* eval();
}

if (e->getType() == TYPE_BOOL) {
    //OK
}
else {
    //NOK
}



class Constraint {
    private:
        Expression* e;
    
        eval()
}

Lex Yacc

constraint X + Y;

/////

var x with domain {1, 2, 3, 4, 5, 6, 7}

...

constraint x >= 4 // varCount == 1
